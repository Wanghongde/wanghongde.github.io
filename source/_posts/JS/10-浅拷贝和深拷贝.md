---
title: 浅拷贝和深拷贝
tags: JS
---

在聊`深拷贝`和`浅拷贝`之前我们先简单介绍下 JS 中的两大数据类型

- 基本数据类型， 基本数据类型存储在**栈**内存中。
- 引用数据类型， 引用数据类型存储在**堆**内存中，引用数据类型的变量是一个指向堆内存中的对象的引用，存在栈中。

<!--more-->

`浅拷贝`指的是创建新的数据，这个新数据，有原始数据属性值的一份精确拷贝。

如果是基本数据类型，拷贝的就是基本数据类型的值。

如果是引用数据类型，拷贝的是引用数据的内存地址。

简单说，`浅拷贝`只拷贝一层，深层次的引用类型则共享内存地址。

那我们来简单实现下：

```js
function shallowClone(obj) {
  let newObj = {}

  for(let key in obj) {
    if(obj.hasOwnProperty(obj[key])) {
      newObj[key] = obj[key]
    }
  }

  return newObj
}

shallowClone(obj)
```

在 JS中，存在`浅拷贝`的现象有：

- `Object.assign`

```js
var obj = {
    age: 18,
    names: {
        name1: '张三',
    },
    sayHi: function () {
        console.log('我是张三')
    }
}
var newObj = Object.assign({}, fxObj)

obj.names.name1 = '李四'

console.log(newObj.names.name1) // 李四
```

- 使用扩展运算符

```js
const arr = ["One", "Two", "Three"]
const newArr = [...arr]
newArr[1] = "love"

console.log(arr) // ["One", "Two", "Three"]
console.log(newArr) // ["One", "love", "Three"]
```

- Array.prototype.concat

```js
const arr = ["One", "Two", "Three"]
const newArr = arr.concat()
newArr[1] = "love"

console.log(arr) // ["One", "Two", "Three"]
console.log(newArr) // ["One", "love", "Three"]
```

`深拷贝`开辟一个新空间，两个对象属性完全相同，但对应两个不同的地址，修改一个对象的属性，另一个不会受影响。

- `lodash ` 的  `_.cloneDeep()`

```js
import _ from 'lodash'

const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
}

const obj2 = _.cloneDeep(obj1)

console.log(obj1.b.f === obj2.b.f) // false
```

- `JSON.stringify`配合 `JSON.parse`

```js
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
}

const obj2 = JSON.parse(JSON.stringify(obj1))

console.log(obj1.b.f === obj2.b.f) // false
```

- 手写循环递归

```js
let obj1 = {
  a:{
    b:1
  }
}

function deepClone(obj) { 
  let cloneObj = {}
  
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ==='object') { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}

let obj2 = deepClone(obj1)

obj1.a.b = 2

console.log(obj2)   //  {a:{b:1}}
```

