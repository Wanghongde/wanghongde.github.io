---
title: 防抖和节流
tags: JS
---

函数`防抖`和`节流`是我们优化高频率代码的一种手段，比如浏览器的 `resize`、`scroll` 、`mousemove`等事件在触发时，会不断的调用绑定到事件上的回调函数，极大的浪费了资源，降低前端性能。

`防抖` 就是 n 秒后再执行该事件，若 n 秒内被重复触发，则重新计时。

`节流` 则是  n 秒内只运行一次，若在 n秒内重复触发，则只有一次生效。

<!--more-->

当我们在表单输入内容并给出搜索建议列表时，如果不加限制，就需要频繁给服务器发送请求，所以这种时候我们应该时让最后一次发送请求，也就是使用`防抖`来优化。

```html
<input type="text" class="content" />

<script>
    let content = document.querySelector('.content')

    // 如果不加限制 则输入每一个字符都会触发请求
    content.oninput = function(e) {
        // 发送请求
        console.log(e.target.value)
    }
</script>
```

所以，这里我们可以使用`防抖`来优化减少请求次数，减轻服务器压力。

```html
<input type="text" class="content" />

<script>
    let content = document.querySelector('.content')

    function debounce(fn, delay) {
        let timer 

        return function() {
            if(timer) clearTimeout(timer)

            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, delay)
        }
    }

    let fn = function(e) {
        console.log(e.target.value)
    }
    content.oninput = debounce(fn, 200)
</script>
```

当我们给元素注册了鼠标移动事件，只是简单打印，如果不加限制，则会频繁触发，所以此时我们可以使用`节流`来进行优化。

```html
<style>
    .container {
        width: 500px;
        height: 500px;
        background-color: pink;
    }
</style>

<div class="container"></div>

<script>
    function throttle(fn, delay) {
        let timer  

        return function() {
            if(timer) return

            timer = setTimeout(() => {
                fn.apply(this, arguments)
                timer = null
            }, delay)
        }
    }

    let container = document.querySelector('.container')

    function fn(){
        console.log(123)
    }

    container.onmousemove = throttle(fn, 100)
</script>
```

我们可以看出 其实`防抖`和`节流` 其实差不多，都是使用`setTimeout` 再配合`apply`调用函数。

区别在于， `防抖`是当在 n 秒内触发函数，则 `clearTimeout`清除上一次事件，开启新的定时器。

`节流`的关键是 当 n 秒内触发函数，则 return，等n 秒后触发上一次事件。