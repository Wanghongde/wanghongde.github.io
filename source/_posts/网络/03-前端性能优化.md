---
title: 前端性能优化
tags: 网络
---

性能优化是一个特别大的话题，我这里也只是简单说下我的理解

与其说性能优化，不如换一个简单的话`访问的网站快准狠的呈现到用户面前`

我们这里聊的性能优化，其实只是总结梳理一些常见的方式，面对真实的项目肯定不能一点一点去尝试，比较通用的方案是全链路埋点，通过数据查看哪块慢了，通过数据去量化性能优化，当然我们这里就不去最小的粒度化去分析，因为那最少需要几万字来梳理了。

<!-- more -->

### 图片优化

图片优化是一个相对比较简单，但是却可以大幅提升我们性能的方式

- 降低图片质量，图片100%的质量，和60%的质量其实看不出太大区别，一是可以使用`webpack`进行图片压缩， 二是可以使用在线网站进行压缩，比如我常用的一个`shrinkme`
- 使`WebP`格式图片，优势在于有更小的图片体积，且拥有肉眼识别无差异的图片质量，兼容性不太好，但现已经慢慢抛弃低版本浏览器
- 图片转成`base64` ，因为经过编码后，减少了`http`的请求次数，但图片体积会稍微增大，所以只适合小图片转化
- 使用字体图标，它更`轻量`一个图标字体比一个图像要小，也更`灵活`通过`css` 可以随意更改颜色、阴影、透明度、旋转等
- 图片延时加载也就是`图片懒加载`，先不给图片设置路径，只有当图片出现在浏览器可视窗口，才去加载真正的图片。

```html
<img data-src="https://avatars.githubusercontent.com/u/20986264?v=4">

<script>
const img = document.querySelector('img')
    
window.addEventListener('scroll', function() {
    let result = img.getBoundingClientRect()
    if(result.top < document.documentElement.clientHeight) {
        img.src = img.dataset.src
    }
})
</script>
```

### 压缩

压缩文件也是个接入成本比较低的性能优化策略

- 借助于 `webpack` 的各种`loader`和`plugin` 可以帮我们快速压缩合并`js`、`html`、`css` 等
- 当然也可以开启`gzip` 压缩，打包的时候生成gz文件，上传到服务器，就不需要服务器来压缩，既降低了服务器压力，也减小了文件体积，`webpack`可以使用`comperssion-webpack-plugin`来设置
- 依赖`es6`的模块静态分析特性，我们可以让`webpack`开启 `tree shaking` ,将我们的功能保持不变，并能将无用代码剔除

### HTTP

- 完整的`http`请求，需要经历`DNS`查找，`TCP握手`，浏览器发出请求，服务器接受请求，服务器处理请求并相应，浏览器接收响应等等一系列过程，所以`减少http请求次数`,也就是适当的`合并文件`、`雪碧图`、`合并代码块`提升我们的性能
- 使用 `http2`， 它有解析速度更快，且有多路复用的特点，还回减少相同头部请求字段的数量等
- 善用缓存，一些不经常更新的资源比如`vue`等一些列第三方的包，我们可以开启强缓存，通过`Expires`和` max-age `来设置缓存有效时间，也可以开启协商缓存，使用`Etag`和`If-None-Match`

### CDN

- 内容分发网络`CDN` ，是一组分布在多个不同地理位置的 Web 服务器， 接入成本就比较高了，需要资金支持，原理就是把网站的`静态资源`比如不常变化的样式、图片、文字、视频等全部部署到`CDN服务器`里，用户在请求时找最近的服务器获取资源，从而缩短了请求时间。

### 其他优化小手段

- 减少 `cookie` 体积
- 使用`骨架屏`优化白屏
- 长列表虚拟滚动
- `JS`加载方式的设置
  - `async`模式：当该`JS`资源和`页面DOM`没有依赖关系比如`埋点统计`,则可以设置`async`属性，`async`属性代表加载时异步的，`JS`不会阻塞DOM的渲染，当`JS资源`加载结束，会立即执行
  - `defer`模式：该`JS资源`加载也是异步的，但是`JS脚本`需要等待`DOM`准备好再执行
- 路由懒加载、组件懒加载，一定注意适度不能过多的拆分资源导致`http`请求过多
- 减少重绘重排