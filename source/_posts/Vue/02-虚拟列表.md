---
title: Vue的虚拟列表
tags: Vue
---
我们在渲染移动端页面时，有时会遇到特别多的数据，渲染这种列表就叫`长列表`

`长列表`如果直接渲染到页面， 当列表项数过多并且列表项结构复杂的时候 ，会造正页面有大量的DOM需要处理，非常容易造成卡顿甚至卡死。

常见的一种解决方式就是`虚拟列表`，那我们就来一起写一个简单的`虚拟列表`吧。

<!-- more -->

`虚拟列表`就是按需显示，既只对可视区域进行渲染，滚动出去的内容和将要出现的内容，不渲染或者部分渲染。

假如屏幕高度(可视区域)是`750px`，每一项是`75px`高，屏幕只能展示出条数据，那我们在渲染时，就展示10条数据。

屏幕发生滚动，我们就对应的修改这10条数据就可以了。

接下来我们来具体实现下：

### 模拟数据

我们在父组件先准备一个 长度为10000的数据列表

```js
let arr = new Array(1000).fill({}).map((item, index) => ({ 
  id: index,
  title: `我是测试标题---${index}`,
  avatar: `https://t11.baidu.com/it/u=2162308300,96045043&fm=58`
}))

let itemHeight = 75
```

然后传递给子组件

```vue
 <list :list="data" :itemHeight="itemHeight">  // 传入给子组件数据 和 每一项的高度
     <template #default="{item}">   // 这里使用插槽可以自定义子组件项目的展示样式
         <div class="item-box">
             <img :src="item.avatar" alt="">
             <span>{{ item.title }}</span>
         </div>
     </template>
 </list>
```

子组件进行接收数据

```typescript
interface item {
  id: number,
  title: string,
  avatar: string
}

interface props {
  list: Array<item>,
  itemHeight?: number
}

let Props = withDefaults(defineProps<props>(), {
  itemHeight: 120
})  // 这是是防止父组件不传递高度 设置一个子项默认值 120高

let {list, itemHeight} = toRefs(Props)  // 为了方便使用我们将数据结构出来
```

我们知道数据有一万条，可页面只能渲染大概10条数据，但是滚动条是希望出现的呀，所以在页面结构上我们需要花点心思路, 我们创建的`empty-box` 就是为了撑开`container-out`，让他有一个滚动条，那到底`empyt-box`盒子需要多高呢，我们就可以使用计算属性进行动态计算了，而`virtual-list`则是盛放滚动页面就修改的10条数据的。

```vue
<div class="container-out">
    <div class="container-scroll">
        <div class="empty-box" :style="{height: emptyBoxHeight + 'px'}"></div>
        <div class="virtual-list">

        </div>
    </div>   
</div>

<script setup lang='ts'>
    ...
    ...
    const emptyBoxHeight = computed<number>(() => list.value.length * itemHeight.value) 
</script>

<style scoped lang="less">
.container-out {
  height: 100%;
  width: 100%;
}

.container-scroll {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: auto;
  .empty-box {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
  }
  .virtual-list {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
   }
 }
</style>
```

页面撑开了，滚动条也是真实的滚动条需要的长度了，但是数据没准备了

```vue
<div class="container-out">
    <div class="container-scroll" ref="containerScrollRef">
        <div class="empty-box" :style="{height: emptyBoxHeight + 'px'}"></div>
        <div class="virtual-list">
            <!-- 将计算出的数据渲染到页面 -->
            <div class="item" v-for="item in renderList" :key="item.id">
              <slot name="default" :item="item">
                {{ item }}
              </slot>
            </div>
        </div>
    </div>   
</div>

<script>
    ...
    ...
	let containerScrollRef = ref<HTMLDivElement>() // 获取到滚动盒子的容器
   	let containerScrollRefHeight = computed<number>(() => {  // 获取滚动盒子的高度
        return containerScrollRef.value ? containerScrollRef.value.clientHeight : 0
    })
    
    let pageShowCount = computed<number>(() => {  // 计算一行展示多少条数据
        return Math.ceil(containerScrollRefHeight / item.value)
    })
    
    let start = ref<number>(0) 
	let end = computed<number>(() => start.value + pageShowCount.value)
    
    const renderList = computed(() => {
        let realEnd = Math.min(end.value, list.value.length)  // 防止计算后的最后一条数据超出数组总长度
        return list.slice(start, realEnd)  // 从list中截取出要渲染的数据
    })
</script>
```

接下来我们需要注册`滚动事件`了，当滚动滚动条，我们就需要将`virtual-list`通过css3的`transform`滚动应该滚动的距离，并重新计算要渲染的数据

```vue
<div class="container-out">
    <div class="container-scroll" ref="containerScrollRef" @scroll="onScroll">
        <div class="empty-box" :style="{height: emptyBoxHeight + 'px'}"></div>
        <!-- 我们需要当页面滚动 也滚动virtual-list 这样才不会出现跳屏 -->
        <div class="virtual-list" :style="translateValueStyle">
            <!-- 将计算出的数据渲染到页面 -->
            <div class="item" v-for="item in renderList" :key="item.id">
              <slot name="default" :item="item">
                {{ item }}
              </slot>
            </div>
        </div>
    </div>   
</div>

<script>
	...
    ...
    function onScroll(event:UIEvent) {
      let container = event.target as HTMLDivElement  // 获取 滚动容器

      if(!container) return 

      const {scrollTop} = container  // 结构滚动容器滚动出去的距离
      
	  // 计算新的需要渲染的数据开始的索引
      start.value = Math.floor(scrollTop / itemHeight.value)  

      // 相应的计算出虚拟列表滚动的距离  
      translateValue.value = start.value * itemHeight.value
    }
    
    const translateValue = ref<number>(0)

    // 将css 滚动的距离通过 style绑定到页面
    const translateValueStyle = computed(() => {
      return `transform:translate(0, ${translateValue.value}px)`
    })

</script>
```

